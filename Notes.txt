import cv2
import numpy as np
from matplotlib import pyplot as plt
import os
import glob
import math
import PIL

def EdgeDetection():
#Edge Detection
# Read the original image
    img = cv2.imread('C:/Users/Jess/Documents/chessBoard.jpg')
# Display original image
    cv2.imshow('Original', img)
    cv2.waitKey(0)
# Convert to graycsale
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Blur the image for better edge detection
    img_blur = cv2.GaussianBlur(img_gray, (5,5), 0)

# Canny Edge Detection
    edges = cv2.Canny(image=img_blur, threshold1=15, threshold2=60) # Canny Edge Detection
# Display Canny Edge Detection Image
    cv2.imshow('Canny Edge Detection - 40, 100', edges)
    cv2.imwrite('C:/Users/Jess/Documents/chessBoardEdgeDetection_15-75_1x1blur.jpg', edges)
    cv2.waitKey(0)

def templateMatching(): 
    #Template Matching
    img_rgb = cv2.imread('C:/Users/Jess/Documents/ChessVision/blankBoardCropped.jpg')
    img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
    
    #whiteTemplate = cv2.imread('C:/Users/Jess/Documents/ChessVision/whiteTemplate2.jpg',0)
    #whiteHeight, whiteWidth = whiteTemplate.shape[::]
    #whiteRes = cv2.matchTemplate(img_gray, whiteTemplate, cv2.TM_CCOEFF_NORMED)
    
    
    blackTemplate = cv2.imread('C:/Users/Jess/Documents/ChessVision/blackTemplate.jpg',0)
    blackHeight = blackTemplate.shape[0]
    blackWidth = blackTemplate.shape[1]
    blackRes = cv2.matchTemplate(img_gray, blackTemplate, cv2.TM_CCOEFF_NORMED)
    #blackloc = np.where(blackRes > threshold)
    #for pt in zip(*blackloc[::-1]):
        #cv2.rectangle(img_rgb, pt,(pt[0] + blackWidth, pt[1] + blackHeight), (0, 0, 255), 1)
    #cv2.imshow("Matched image", img_rgb)
    #cv2.imwrite('C:/Users/Jess/Documents/ChessVision/chessBoardMatchedWhite.jpg', img_rgb)

# search for max score
    result = img_rgb.copy()
    threshold = 0.57
    max_val = 1
    
    rad = int(math.sqrt(blackHeight*blackHeight+blackWidth*blackWidth)/4)
    while max_val > threshold:

    # find max value of correlation image
        min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(blackRes)
        print(max_val, max_loc)

        if max_val > threshold:
        # draw match on copy of input
            cv2.rectangle(result, max_loc, (max_loc[0]+blackWidth, max_loc[1]+blackHeight), (0,0,255), 1)
            print(max_val)

        # write black circle at max_loc in corr_img
            cv2.circle(blackRes, (max_loc), radius=rad, color=0, thickness=cv2.FILLED)

        else:
            break;

    #rad = int(math.sqrt(whiteHeight*whiteHeight+whiteWidth*whiteWidth)/4)
    #max_val = 1
    #threshold = 0.57
    #while max_val > threshold:

    # find max value of correlation image
        #min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(whiteRes)
        #print(max_val, max_loc)

        #if max_val > threshold:
        # draw match on copy of input
            #cv2.rectangle(result, max_loc, (max_loc[0]+whiteWidth, max_loc[1]+whiteHeight), (255,0,00), 1)
            #print(max_val)

        # write black circle at max_loc in corr_img
            #cv2.circle(whiteRes, (max_loc), radius=rad, color=0, thickness=cv2.FILLED)

        #else:
            #break
    cv2.imshow("Matched image", result)
    cv2.imwrite('C:/Users/Jess/Documents/ChessVision/chessBoardMatchedComputerTemplateBlack.jpg', result)
    cv2.waitKey(0)

def findCorners():
    img_rgb = cv2.imread('C:/Users/Jess/Documents/ChessVision/blankBoard.jpg')
    image = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
    retval, corners = cv2.findChessboardCorners(image, patternSize, flags)
    cv2.cornerSubPix(image, corners, winSize, zeroZone, criteria)

def calibrateCorners():
    # Defining the dimensions of checkerboard
    CHECKERBOARD = (8,8)
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

     #Creating vector to store vectors of 3D points for each checkerboard image
    objpoints = []
# Creating vector to store vectors of 2D points for each checkerboard image
    imgpoints = [] 

# Defining the world coordinates for 3D points
    objp = np.zeros((1, CHECKERBOARD[0] * CHECKERBOARD[1], 3), np.float32)
    objp[0,:,:2] = np.mgrid[0:CHECKERBOARD[0], 0:CHECKERBOARD[1]].T.reshape(-1, 2)
    prev_img_shape = None

# Extracting path of individual image stored in a given directory
    images = glob.glob('./ChessVision/images/*.jpg')
    for fname in images:
        img = cv2.imread(fname)
        gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    # Find the chess board corners
    # If desired number of corners are found in the image then ret = true
        ret, corners = cv2.findChessboardCorners(gray, CHECKERBOARD, cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_FAST_CHECK + cv2.CALIB_CB_NORMALIZE_IMAGE)
    
        if(ret == True):
            objpoints.append(objp)
            # refining pixel coordinates for given 2d points.
            corners2 = cv2.cornerSubPix(gray, corners, (11,11),(-1,-1), criteria)
        
            imgpoints.append(corners2)

        # Draw and display the corners
            img = cv2.drawChessboardCorners(img, CHECKERBOARD, corners2, ret)
    
        cv2.imshow('img',img)
        cv2.waitKey(0)

        h,w = img.shape[:2]

        
        ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
        print("Camera matrix : \n")
        print(mtx)
        print("dist : \n")
        print(dist)
        print("rvecs : \n")
        print(rvecs)
        print("tvecs : \n")
        print(tvecs)

def picColors():
    img_rgb = cv2.imread('C:/Users/Jess/Documents/ChessVision/blankBoard.jpg')
    img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
    #print(img_rgb)
    img_rgb .reshape(-1, 3)
    unique, counts = np.unique(img_rgb.reshape(-1,3), axis = 0, return_counts = True)
    print('unique: ',unique)
    print('counts: ',counts)
    print('Most common by argmax: ', unique[np.argmax(counts)])
    colorSort = np.argsort(counts)
    print('Most common: ', unique[colorSort[len(counts)-1]])
    print('Second most common: ', unique[colorSort[len(counts)-2]])
    print('Ten most common colors: ')
    for i in range(1,20):
        print(i)
        print(unique[colorSort[len(counts)-i]])

def create_blank(width, height, color=(0, 0, 0)):
    """Create new image(numpy array) filled with certain color in RGB"""
    # Create black blank image
    image = np.zeros((height, width,3), np.uint8)

    # Since OpenCV uses BGR, convert the color first
    #color = tuple(reversed(rgb_color))
    # Fill image with color
    image[:] = color

    return image

# Create new blank 300x300 red image

def mostCommonColor(image):
    img_rgb = cv2.imread(image)
    img_rgb .reshape(-1, 3)
    unique, counts = np.unique(img_rgb.reshape(-1,3), axis = 0, return_counts = True)
    return unique[np.argmax(counts)]


def main():
    width, height = 162, 162
    black = mostCommonColor('C:/Users/Jess/Documents/ChessVision/blankBoardCropped.jpg')
    blackTemplate= create_blank(width, height, black)
    cv2.imwrite('C:/Users/Jess/Documents/ChessVision/blackTemplate.jpg', blackTemplate)
    templateMatching()
    #picColors()
    print('done')
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
